<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by TEMPLATED
http://templated.co
Released for free under the Creative Commons Attribution License
Name       : MetroBiz 
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20140207
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>What Rock Ya Got - Sedimentary</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900" rel="stylesheet" />
<link href="../default.css" rel="stylesheet" type="text/css" media="all" />
<link href="../fonts.css" rel="stylesheet" type="text/css" media="all" />

<!--[if IE 6]><link href="default_ie6.css" rel="stylesheet" type="text/css" /><![endif]-->

</head>
<body>
<div id="header-wrapper">
	<div id="header" class="container">
		<div id="logo">
			<h1 style="color : white;">What Rock Ya Got</h1>
			<span>Sedimentary Rock</span>
		</div>
		<p style="background-color : white; color : white">nosey little fucker aren't ya</p>
	</div>
</div>
<div id="wrapper2" class="container">
<p><a href="https://www.whatrockyagot.com">Return<<</a> </p>
		<p><a href="index.html">Reset test</a></p>

</div>

<div id="copyright" class="container">
	<p>&copy; Made by team JavaThehutt | Kent Hackathon | Design by <a href="http://templated.co" rel="nofollow">TEMPLATED</a>.</p>
</div>
</body>
		<script language="JavaScript">
            <!--
            function silentErrorHandler() {return true;}
            window.onerror=silentErrorHandler;
            //-->
            
            /**
             * Produce and run through data trees for rocks!
             *
             * @author Lars Dreith
             * October 7th, 2017
             */
            
            
             //imported from code.stephenmorley.org
            function Queue(){var a=[],b=0;this.getLength=function(){return a.length-b};this.isEmpty=function(){return 0==a.length};this.enqueue=function(b){a.push(b)};this.dequeue=function(){if(0!=a.length){var c=a[b];2*++b>=a.length&&(a=a.slice(b),b=0);return c}};this.peek=function(){return 0<a.length?a[b]:void 0}};
            
            
            // produce a button object
            function newButton(text){
                var btn = document.createElement("Button");
                var t = document.createTextNode(text);
                btn.appendChild(t);
                return btn;
            }
            
            // One cycle of our program
            function buttonNamesArray(node){
                
                // print out question from node //
                var q = document.createElement("h1");
                var t = document.createTextNode(node.data[2]);
                q.appendChild(t);
               
				//!!!
				document.getElementById("wrapper2").appendChild(q);
		
		window.scrollTo(0,document.body.scrollHeight);
                
                console.log(node.children);
                list = node.children;
                
                // make buttons for each child of node //
                
                // basically copied from some random stack exchange website lol
                var funcs = [];
                function createfunc(i){
                    return eventThing(i, node);
                }
                for( var i = 0; i < node.children.length; i++){
                    funcs[i] = createfunc(i);
                }
                for (var j = 0; j < node.children.length; j++){
                    funcs[j]();
                }    
            }
            
            // a function so that the other function doesn't actually become incomprehensible
            function eventThing(i, node){
                    next = node.children[i];
                    let option = newButton(next.data[1]);
                   // !!
				document.getElementById("wrapper2").appendChild(option);
                    option.setAttribute("class", "button");
                    option.id = node.children[i].data[0];
                    //option.setAttribute("onClick", "execute()");
                    console.log(node);
                    (function(){
                        document.getElementById(node.children[i].data[0]).addEventListener('click', function(){handleClick(node.children[i]);});
                    }());
            }
            
            // A function so that the other function doesn't actually become incomprehensible
            function handleClick( nodeChild){
                console.log(nodeChild);
                document.getElementById(nodeChild.data[0]).style.background = '#9b9b9b';
                
                // stops old buttons from being clicked
                var x = document.getElementsByClassName("button");
                for( i = 0; i < x.length; i++ ){
                    var clone = x[i].cloneNode();
                    while (x[i].firstChild) {
                        clone.appendChild(x[i].lastChild);
                    }
                    x[i].parentNode.replaceChild(clone, x[i]);
                }
                
                buttonNamesArray(nodeChild);
            }
            
            // line break constant... necessary???
            const br = document.createElement("br");
                 //      Node, Tree, and their relevant methods to build the data tree!      //
            function Node(data){
                this.data = data;
                this.parent = null;
                this.children = [];
            }
            
            function Tree(data){
                var node = new Node(data);
                this._root = node;
            }
            
            
            Tree.prototype.traverseBF = function(callback) {
                var queue = new Queue();
     
                queue.enqueue(this._root);
 
                currentTree = queue.dequeue();
 
                while(currentTree){
                    for (var i = 0, length = currentTree.children.length; i < length; i++) {
                        queue.enqueue(currentTree.children[i]);
                    }
 
                    callback(currentTree);
                    currentTree = queue.dequeue();
                }
            };
            
            Tree.prototype.contains = function(callback, traversal) {
                traversal.call(this, callback);
            };
            
            Tree.prototype.add = function(data, toData) {
                var child = new Node(data),
                    parent = null,
                    callback = function(node) {
                        if (node.data[0] === toData) {
                            parent = node;
                        }
                };
 
                this.contains(callback, tree.traverseBF);
 
                if (parent) {
                    parent.children.push(child);
                    child.parent = parent;
                } else {
                    throw new Error('Cannot add node to a non-existent parent.');
                }
            };
            
                        //      The Thing that does the things      //
            // declaring our data tree
            var tree = new Tree(["root", "", "What kind of rock do you have?"]);
            // calling the root of our data tree
            
            // Library //
			tree.add(["Sedimentary_1", "Sedimentary", "Does this rock react with acid"], "root");

            
            //      Sedimentary Rocks   //
            
            tree.add(["Acid_2", "Reacts to acid", "Does this rock need to be powered to react w/ HCL?"], "Sedimentary_1");
            tree.add(["NotAcid_2", "Does not react with acid", "What is the grain size/texture?"], "Sedimentary_1");
            
            tree.add(["RPTR~3", "Rock must be broken up into a powder to react", "..."], "Acid_2");
            tree.add(["NRPTR~3", "Rock does not need to be powdered to react", "What is the appearance?"], "Acid_2");
            
            tree.add(["LGTW~4", "dwl luster, gray, tar, white, may be other colors", "Dolomite"], "RPTR~3");
            
            tree.add(["AFP~4", "Abundant fossils present", "What is the composition?"], "NRPTR~3");
            tree.add(["MS~4", "miniature spheres, like tiny pears; white gray common", "oolitic limestone"], "NRPTR~3");
            tree.add(["WPG~4", "white powdery, feels gritty", "chafe limestone"], "NRPTR~3");
            tree.add(["GFSD~4", "Fine grained, smooth, dense, irregular, blocky", "micrite limestone"], "NRPTR~3");
            
            tree.add(["FGM~5", "Fine grained matrix w/ many fossils", "fossil limestone"], "AFP~4");
            tree.add(["PLWBS~5", "Porous, light weight, broken shell fragments, tan to white", "coquina"], "AFP~4");
            
            tree.add(["GVRG~3", "Grains visible or rock feels gritty", "Is the main mass of rock visible?"], "NotAcid_2");
            tree.add(["NGMFG~3", "No Grains, may feel gritty or glassy", "What is the texture?"], "NotAcid_2");
            tree.add(["BLWS~3", "Black, light weight, smudgy, or shiny", "coal"], "NotAcid_2");
            tree.add(["WPCC~3", "White, pink, clear crystals", "Color and taste(don't go around licking rocks though)"], "NotAcid_2");
            
            tree.add(["NV~4", "Gravel actual rock, not visible", "What is the shape of the grain?"], "GVRG~3");
            tree.add(["V~4", "Gravel, but rock still visible", "..."], "GVRG~3");
            
            tree.add(["AGG~5", "Angular Gravel Grains", "Breccia"], "NV~4");
            tree.add(["RGG~5", "Rounded Gravel Grains", "conglomerate"], "NV~4");
            
            tree.add(["GDV~5", "Grains distinct and visible", "Sandstone"], "V~4");
            
            tree.add(["FGNP~4", "Feels Gritty, no particles even under microsope", "Silt Stone"], "NGMFG~3");
            tree.add(["SCG~4", "Smooth curves, glassy, durl laster many colors", "chert"], "NGMFG~3");
            tree.add(["FSDNS~4", "Feels smooth, does not scratch by fingernail, layered", "shale"], "NGMFG~3");
            
            tree.add(["ST3RPF~4", "Salty taste, 3 right perfect angles, clear gray", "rock salt"], "WPCC~3");
            tree.add(["SFN,POW~4", "Softer than finger nail, pink or white, fiberous thic plates or tense", "gypsum"], "WPCC~3");
            

            
            
                                    //      The Thing that does the things      //

            // calling the root of our data tree
            buttonNamesArray(tree._root.children[0]);
            
        </script>

</html>



